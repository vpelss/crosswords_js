<!DOCTYPE HTML PUBLIC "-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//EN" "hmpro6.dtd">
<HTML>
  <HEAD> <LINK REL="stylesheet" TYPE="text/css" HREF="main.css"><META
	NAME="KEYWORDS"
	CONTENT="Crosswords , Friends ,infinite , instant , unlimited , crossword , cross, word, generator , puzzle , script , crosswords, printable">
	<META NAME="DESCRIPTION"
	 CONTENT="Crosswords for Friends. Infinite Crossword Puzzle Generator Script to create Crosswords for prining or saving for use in your web browser">

	<TITLE>Emogic's Crosswords Puzzle Generator</TITLE> <SCRIPT SRC="./js/jquery-1.11.3.min.js"></SCRIPT>
  </HEAD>
  <BODY BACKGROUND="crossword.gif" STYLE="main.css">
	<CENTER>
	  <TABLE CELLPADDING="0" CELLSPACING="1" BGCOLOR="#000000">
		<TR>
		  <TD>
			<TABLE CELLPADDING="5" CELLSPACING="0" BGCOLOR="#FFFFFF">
			  <TR>
				<TD COLSPAN="3">
				  <H6 ALIGN="CENTER">Back to <A HREF="/">Emogic</A></H6>
				  <H3 ALIGN="CENTER"><A HREF="/">Emogic's</A> Crossword
					Generator </H3></TD>
			  </TR>
			  <TR>
				<TD
				 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
				 VALIGN="TOP">
				  <CENTER>
					<FORM ACTION="crossword.cgi" METHOD="POST"
					 NAME="StartForm" ID="StartForm">
					  <P></P> <HR>
					  <TABLE BORDER="0">
						<TR>
						  <TD VALIGN="TOP">
							<TABLE CELLPADDING="0" CELLSPACING="0"
							 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
							 WIDTH="100%">
							  <TR>
								<TD VALIGN="TOP" COLSPAN="2"
								 ALIGN="CENTER"><INPUT TYPE="radio" NAME="layouts" CHECKED="CHECKED"
								  VALUE="grids"><A HREF="#"
								  ONCLICK="alert(gridsvar);return false;">Grids</A></TD>
							  </TR>
							  <TR>
								<TD VALIGN="TOP">
								  <SELECT id="grid" NAME="grid" SIZE="6" onchange="grid_change(this.value);">
									<OPTION VALUE="3x3"
									 CLASS="gridOption">Double Word Squares - no black squares</OPTION>
									<OPTION VALUE="3x3">3x3</OPTION>
									<OPTION VALUE="4x4">4x4</OPTION>
									<OPTION VALUE="5x5">5x5</OPTION>
									<OPTION VALUE="6x6">6x6</OPTION>
									<OPTION VALUE="7x7">7x7</OPTION>
									<OPTION VALUE="13x13_56_144"
									 CLASS="gridOption">Standard USA Grids</OPTION>
									<OPTION VALUE="13x13_56_144"
									 SELECTED="SELECTED">13x13_56_144</OPTION>
									<OPTION
									 VALUE="13x13_56_144b">13x13_56_144b</OPTION>
									<OPTION
									 VALUE="13x13_60_146">13x13_60_146</OPTION>
									<OPTION
									 VALUE="13x13_62_145">13x13_62_145</OPTION>
									<OPTION VALUE="15x15">15x15</OPTION>
									<OPTION
									 VALUE="16x16_80_42">16x16_80_42</OPTION>
									<OPTION
									 VALUE="17x17_100_48">17x17_100_48</OPTION>
									<OPTION
									 VALUE="19x19_116_58">19x19_116_58</OPTION>
									<OPTION VALUE="21x21">21x21</OPTION>
									<OPTION
									 VALUE="21x21_126_64">21x21_126_64</OPTION>
									<OPTION VALUE="BigOne">BigOne</OPTION>
									<OPTION
									 VALUE="21x27_178_92">21x27_178_92</OPTION>
									<OPTION
									 VALUE="23x23_160_87">23x23_160_87</OPTION>
									<OPTION VALUE="13x13_22_112"
									 CLASS="gridOption">British Style</OPTION>
									<OPTION
									 VALUE="13x13_22_112">13x13_22_112</OPTION>
									<OPTION
									 VALUE="15x15_26_138">15x15_26_138</OPTION>
									<OPTION
									 VALUE="21x21_44_292">21x21_44_292</OPTION>
								  </SELECT><BR></TD>
								<TD VALIGN="TOP"></TD>
							  </TR>
							</TABLE><BR>
							<TABLE BORDER="0"
							 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
							 WIDTH="100%">
							  <TR>
								<TD ALIGN="CENTER"><INPUT TYPE="radio"
								  NAME="layouts" VALUE="doublespaced">
								  <A HREF="#" ONCLICK="alert(britishgridsvar);return false;">British Grids
								  Random</A><BR><BR>Width/Height
								  <INPUT TYPE="TEXT" NAME="doublespacedwidth" SIZE="3" VALUE="7"><BR><INPUT
								  TYPE="CHECKBOX" NAME="evenodd" VALUE="1">Even/Odd<BR><INPUT TYPE="TEXT"
								  NAME="doublespacedpercentage" VALUE="65" SIZE="3">PercentageWhite<BR><BR><INPUT
								  TYPE="CHECKBOX" NAME="doublespacedfull" VALUE="1"> Full (100% white)</TD>
							  </TR>
							</TABLE><BR>
							<TABLE BORDER="0"
							 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
							 WIDTH="100%">
							  <TR>
								<TD ALIGN="CENTER"><A HREF="#"
								  ONCLICK="alert(slowdownvar);return false;">Slow Down</A><BR><INPUT TYPE="TEXT"
								  NAME="SlowDown" VALUE="0" SIZE="3"> 5 seconds max</TD>
							  </TR>
							</TABLE>
							<TABLE BORDER="0"
							 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
							 WIDTH="100%">
							  <TR>
								<TD ALIGN="CENTER"><INPUT TYPE="CHECKBOX"
								  NAME="shuffle" CHECKED="CHECKED">
								  <A HREF="#" ONCLICK="alert(shufflevar);return false;">Suffle
								  Words/Letters</A></TD>
							  </TR>
							</TABLE></TD>
						  <TD>
							<TABLE CELLPADDING="0" CELLSPACING="0"
							 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
							 WIDTH="100%">
							  <TR>
								<TD VALIGN="TOP" COLSPAN="2" ALIGN="CENTER"><A
								  HREF="#" ONCLICK="alert(worddatabasevar);return false;">Word Databases</A></TD>

							  </TR>
							  <TR>
								<TD VALIGN="TOP">
								  <INPUT TYPE="radio" NAME="wordfile" CHECKED="CHECKED" VALUE="Clues_248505">
								  <A HREF="./wordlists/Clues_248505/stats.txt" TARGET="_blank">248,505 Words</A>
								  (recommended)<BR> <INPUT TYPE="radio" NAME="wordfile" VALUE="Sympathy_31121">
								  <A HREF="./wordlists/Sympathy_31121/stats.txt" TARGET="_blank">31,121
								  Words</A><BR>
								  <INPUT TYPE="radio" NAME="wordfile" VALUE="Magnum_Eng_Clues_30420">
								  <A HREF="./wordlists/Magnum_Eng_Clues_30420/stats.txt" TARGET="_blank">30,420
								  Words</A><BR> <INPUT TYPE="radio" NAME="wordfile"
								  VALUE="CrosswordSolver_18790">
								  <A HREF="./wordlists/CrosswordSolver_18790/stats.txt" TARGET="_blank">18,790
								  Words</A><BR> <INPUT TYPE="radio" NAME="wordfile" VALUE="CSolver_18675">
								  <A HREF="./wordlists/CSolver_18675/stats.txt" TARGET="_blank">18,675
								  Words</A><BR>
								  <INPUT TYPE="radio" NAME="wordfile" VALUE="CrosswordComiler_17763">
								  <A HREF="./wordlists/CrosswordComiler_17763/stats.txt" TARGET="_blank">17,763
								  Words</A><BR> </TD>
								<TD VALIGN="TOP"></TD>
							  </TR>
							</TABLE><BR>
							<TABLE BORDER="0"
							 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
							 WIDTH="100%">
							  <TR>
								<TD ALIGN="CENTER"><A HREF="#"
								  ONCLICK="alert(walkpathvar);return false;">WalkPath</A></TD>
							  </TR>
							  <TR>
								<TD ALIGN="CENTER">
								  <SELECT NAME="walkpath" SIZE="6"
								   ID="walkpath">
									<OPTION VALUE="crossingwords"
									 CLASS="gridOption">Word Walks</OPTION>
									<OPTION VALUE="crossingwords"
									 SELECTED="SELECTED">Crossing Words (best)</OPTION>
									<OPTION VALUE="zigzag">Zig Zag
									  Words</OPTION>
									<OPTION VALUE="diagonal">Diagonal
									  Words</OPTION>
									<OPTION VALUE="numerical">Numerical
									  Words</OPTION>
									<OPTION VALUE="acrossthendown">Across then
									  Down Words</OPTION>
									<OPTION VALUE="random">Random Words
									  (worst)</OPTION>
									<OPTION
									 VALUE="GenerateNextLetterPositionsOnBoardFlat" CLASS="gridOption">Letter
									  Walks</OPTION>
									<OPTION
									 VALUE="GenerateNextLetterPositionsOnBoardZigZag">ZigZag Letters</OPTION>
									<OPTION
									 VALUE="GenerateNextLetterPositionsOnBoardDiag">Diag Letters</OPTION>
									<OPTION
									 VALUE="GenerateNextLetterPositionsOnBoardFlat">Flat Letters</OPTION>
									<OPTION
									 VALUE="GenerateNextLetterPositionsOnBoardSwitchWalk">Switch Letters</OPTION>
									<OPTION
									 VALUE="GenerateNextLetterPositionsOnBoardSnakeWalk">Snake Letters</OPTION>
								  </SELECT><BR><INPUT TYPE="CHECKBOX"
								  NAME="simplewordmasksearch">
								  <A HREF="#" ONCLICK="alert(simplewordmaskvar);return false;">Simple Word Mask
								  Search</A><HR><INPUT TYPE="CHECKBOX" NAME="optimalbacktrack" VALUE="1"
								  CHECKED="CHECKED">
								  <A HREF="#" ONCLICK="alert(optimumbacktrackvar);return false;">Optimal
								  Backtrack</A> (Recommended)</TD>
							  </TR>
							</TABLE><BR>
							<TABLE BORDER="0"
							 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
							 WIDTH="100%">
							  <TR>
								<TD ALIGN="CENTER"> Calculate Time<BR><INPUT
								  TYPE="TEXT" NAME="TimeLimit" VALUE="5" SIZE="5"> 10 min max </TD>
							  </TR>
							</TABLE></TD>
						</TR>
					  </TABLE>
					  <P><INPUT TYPE="SUBMIT" NAME="Submit1"
						VALUE="Generate Puzzle"></P>
					  <P><INPUT TYPE="RESET" NAME="Reset1"
						VALUE="Reset Defaults"></P> </FORM> </CENTER>
				  <P ALIGN="CENTER"><A HREF="/crosswords/common/"><B>Crossword
					Puzzle Archive</B></A></P></TD>
				<TD
				 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid"
				 VALIGN="TOP" COLSPAN="2" ALIGN="CENTER">
				  <P>Behind the Curtain<BR>Updates every few seconds</P>
				  <FORM><TEXTAREA ROWS="25" COLS="60" ID="PrintProcessing" NAME="PrintProcessing"></TEXTAREA></FORM>
				  <DIV>Crossword Result:
					<DIV ID="PrintResults"
					 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid">YOUR
					  CROSSWORD LINK WILL SHOW HERE</DIV></DIV>
				  <FORM NAME="EraseForm" ID="EraseForm" ACTION="erase.cgi"
				   ONSUBMIT="return;" METHOD="POST">
					<P><INPUT TYPE="SUBMIT" NAME="Submit2"
					  VALUE="Erase stalled crossword generation"><BR>(Use if display above does not
					  update)</P> </FORM> </TD>
			  </TR>
			  <TR>
				<TD COLSPAN="3" ALIGN="CENTER"
				 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid">


				 </TD>
			  </TR>
			  <TR>
				<TD COLSPAN="3" ALIGN="CENTER"
				 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid">Notes
				  about the creation of this Crossword Generator Algorithm and Script:<BR><A HREF="https://www.emogic.com/notes/notes"
				  TARGET="_blank">https://www.emogic.com/notes/notes</A></TD>
			  </TR>
			  <TR>
				<TD COLSPAN="3" ALIGN="CENTER"
				 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid">

				  <P ALIGN="CENTER"><B><FONT COLOR="#CC0000">If you have a
					crossword grid you would like to see, send it to:
					<A HREF="http://www.emogic.com/contact" TARGET="_blank">us</A></FONT></B>. </P>

				  <P ALIGN="CENTER">The format must bei n the format below. The
					white are lowwer case 'o' and the black are lower case 'x'.</P>
				  <PRE>oxxo
oooo
oooo
oxxo</PRE></TD>
			  </TR>
			  <TR>
				<TD COLSPAN="3" ALIGN="CENTER"
				 STYLE="border-top: 1pt solid; border-right: 1pt solid; border-bottom: 1pt solid; border-left: 1pt solid">

				  <P>Thanks to:</P>
				  <P> <A HREF="http://www.cruciverb.com"
					TARGET="_blank">cruciverb.com</A></P>
				  <P><A HREF="http://thesis.cambon.dk/"
					TARGET="_blank">thesis.cambon.dk/</A></P>
				  <P>and <A HREF="http://www.otsys.com/clue" TARGET="_blank">
					www.otsys.com/clue</A></P></TD>
			  </TR>
			</TABLE></TD>
		</TR>
	  </TABLE></CENTER>

<SCRIPT>

var pad_char = 'x';
var unoccupied = 'o';
//var grid_string = '';
//var word_list_strings;

//puzzle will be accessed a lot if using letter searches! but js arrays and associative arrays are comparable ONLY if the key is a simple integer
//{} object will be easier to read in code puzzle[x][y] but is really hard to decipher when looking at the object itself
//[] arrays you will have to start with puzzle[y][x] or make code more complex (not by much) to create array first, OR convert puzzle[y][x] to puzzle[x][y]
//I think the ease of visualizing [] internally for troubleshooting is the better option.
var puzzle = []; // puzzle[y][x] = 'the_letter'
var puzzle_width;
var puzzle_height;
var dir_across = 0;
var dir_down = 1;
var word_lengths = {}; //wordLengths[wordLength] = 1 ; so we have a list of word sizes = object.keys(wordLengths);
//key orders should be [dir][yy][xx] for readability when troubleshooting !!!!!!!!!!!!!!!!!!!
var letter_positions_of_word = []; //letter_positions_of_word[dir][word_number] returns [ ofLetterPositions ];
var position_in_word = []; //position_in_word[dir][yy][xx] = position_count

var this_square_belongs_to_word_number = []; //this_square_belongs_to_word_number[dir][yy][xx]

var allMasksOnBoard = []; //allMasksOnBoard[dir][word_number] returns the mask of letters that have been laid down. eg: XoLoooo

function readStringFromFileAtPath(pathOfFileToReadFrom){
	const request = new XMLHttpRequest();
	request.addEventListener("error", function(){return 0;});
	request.open("GET", pathOfFileToReadFrom, false);
	request.send(null);
	var status = request.status;
	if (status != 200 ) { return status; }
	var returnValue = request.responseText;
	return returnValue;
	}

//grid_change( document.getElementById("grid").value );
function grid_change( file_name ){
  //forget previous setting
  puzzle = [];
  puzzle_width = 0;
  puzzle_height = 0;
  word_lengths = {};
  letter_positions_of_word = [];
  position_in_word = [];
  this_square_belongs_to_word_number = [];
  allMasksOnBoard = [];

  var full_path_file = "./grids/" + file_name + ".txt";
  var grid_string = readStringFromFileAtPath ( full_path_file );
  var lines = grid_string.split(/\r?\n|\r|\n/g); //split on lines into array lines
  if( lines[lines.length-1].trim() == '' ){
   lines.pop();
  }//remove last line if empty

  puzzle_height = lines.length;
  lines.forEach( getLetters ); //process lines array

  //square_grid(); //make the grid a square filling with pad_char on the right
  puzzle.forEach( function(currentValue){
    var arr_length = currentValue.length;
    if(puzzle_width > arr_length) {
     currentValue.length = puzzle_width;
     currentValue.fill(pad_char , arr_length);
    }
  });

  numberBlankSquares();
  tt = 9;
}

function getLetters(currentValue , index) {
 var line = currentValue.trim(); //remove whitespace
 if( line.length > puzzle_width ) {
  puzzle_width = line.length;
  }//keep seeing if we have a larger line width
 var letters = line.split(''); //split line into letters array
 //var t = letters.valueOf();
 letters.forEach( addToPuzzle , index ); //process letters array : index is passed to the function as its this value
 }

function addToPuzzle(currentValue , index) {
 var x = index;// index of letters array
 var y = this.valueOf(); //!! this is the index from/used in getLetters  !!

 if (typeof puzzle[y] === 'undefined') { puzzle[y] = []; }//add second dimension
 puzzle[y][x] = currentValue;
}

function numberBlankSquares(){
 //gridToGlobalVars()
 //this does a lot of var setup
 //and also associate all squares with words and word # , get word lengths on grid ,
//thisSquareBelongsToWordNumber[$xx][$yy][$dir]
//positionInWord[$xx][$yy][$dir] = $PositionCount;
//letterPositionsOfWord[$numberCount][$dir] = [TempLetterPositions];
//allMasksOnBoard[$numberCount][$dir] = $blankWord;

var x , xx;
var y , yy;
var word_length;
var word_number = 0;
var was_there_an_across_word = 0; //
var blank_word = '';
var dir;
var word_pos = [];

//label all grid squares with data
  for (y = 0 ; y < puzzle_height ; y++) {
    for (x = 0 ; x < puzzle_width ; x++) {
      was_there_an_across_word = 0; //assume not
      for (dir = 0 ; dir < 2 ; dir++) { //#for both across 0 and down 1 words
        if(puzzle[y][x] == pad_char){continue;}
        word_pos = getWordPos(x , y , dir);
        if(word_pos){
          if( (word_pos[0][0] == x) && (word_pos[0][1] == y) ){//first letter in word?
             word_length = word_pos.length;
             word_lengths[word_length] = 1; //mark globally that there is a word of this length
             if(! was_there_an_across_word ) word_number++; //allows us to not increase count if across and down share first letter pos
             was_there_an_across_word = 1;
             //set letter_positions_of_word[$numberCount][$dir] = [TempLetterPositions];
             if(typeof letter_positions_of_word[word_number] === 'undefined' ){letter_positions_of_word[word_number] = [];}
             letter_positions_of_word[word_number][dir] = JSON.parse(JSON.stringify(word_pos)); //deep copy multi dim array
             //set allMasksOnBoard[dir][word_number] = 'ooooooooo';
             blank_word = blank_word.padEnd(word_length , unoccupied);
             if(typeof allMasksOnBoard[dir] === 'undefined' ){allMasksOnBoard[dir] = [];}
             allMasksOnBoard[dir][word_number] = blank_word;
             //set position_in_word , this_square_belongs_to_word_number
             word_pos.forEach(function(currentValue , index){
                   //set position_in_word for all word_pos in this word
                   xx = currentValue[0];
                   yy = currentValue[1];
                   if(typeof position_in_word[dir] === 'undefined' ){position_in_word[dir] = [];}
                   if(typeof position_in_word[dir][yy] === 'undefined' ){position_in_word[dir][yy] = [];}
                   position_in_word[dir][yy][xx] = index;
                   //set this_square_belongs_to_word_number[dir][yy][xx] for all word_pos in this word
                   if(typeof this_square_belongs_to_word_number[dir] === 'undefined' ){this_square_belongs_to_word_number[dir] = [];}
                   if(typeof this_square_belongs_to_word_number[dir][yy] === 'undefined' ){this_square_belongs_to_word_number[dir][yy] = [];}
                   this_square_belongs_to_word_number[dir][yy][xx] = word_number;
              });
          }
        }
      }
    }
  }

var crossing_cells = 0;
var total_cells = 0;
var white_cells = 0;
var pad_cells = 0;

//calculate interlock and density
  for(y = 0 ; y < puzzle_height ; y++){
    for(x = 0 ; x < puzzle_width ; x++){
       if(puzzle[y][x] == pad_char){pad_cells++;}
       if(puzzle[y][x] == unoccupied){white_cells++;}
      if( (typeof this_square_belongs_to_word_number[0][y][x] !== 'undefined') && (typeof this_square_belongs_to_word_number[1][y][x] !== 'undefined') ){
          crossing_cells++;
       }
    }
  }

  total_cells = puzzle_height * puzzle_width;
  var interlock = 100 * crossing_cells / total_cells;
  var density = 100 * white_cells / total_cells;

  console.log("Total Cells: " + total_cells);
  console.log("White Cells: " + white_cells);
  console.log("Pad Cells: " + pad_cells);
  console.log("Interlock: " + interlock);
  console.log("Density: " + density);
  console.log("Grid has words of lengths :");
  var wl = Object.keys(word_lengths);
  wl.forEach(function(currentValue){
    console.log(currentValue);
   });

   loadWordList();

}

function getWordPos(x,y,dir){
  var dx,dy;
  var xx = x , yy = y;
  var letter_pos = [];
  [dx,dy] = getDxDy(dir);
  //get to start of word
  while( (typeof puzzle[yy-dy] !== 'undefined') &&  (typeof puzzle[yy-dy][xx-dx] !== 'undefined') && (puzzle[yy-dy][xx-dx] != pad_char) ){
    xx=xx-dx;
    yy=yy-dy;
  }
  letter_pos.push([xx,yy]);
  //now look for all letters of word
  while( (typeof puzzle[yy+dy] !== 'undefined') && (typeof puzzle[yy+dy][xx+dx] !== 'undefined') && (puzzle[yy+dy][xx+dx] != pad_char) ){
    xx=xx+dx;
    yy=yy+dy;
    letter_pos.push([xx,yy]);
  }
  if(letter_pos.length == 1){
    return false;
  }//not a word
  return letter_pos;
}

function getDxDy(dir){
  var dx , dy;
  if(dir == dir_across){
    dx = 1;
    dy = 0;
  }
  if(dir == dir_down){
    dx = 0;
    dy = 1;
  }
return [dx,dy];
}

function loadWordList(){
    var the_text;
    var db = document.querySelector('input[name="wordfile"]:checked').value;
    var wl = Object.keys(word_lengths);
      wl.forEach(function(currentValue){
        var file_and_path = './wordlists/' + db + '/words/' + currentValue + '.txt';
        the_text = readStringFromFileAtPath(file_and_path);
      });

    ii = 9;
    
}

/*

sub LoadWordList {
my $filename = $_[0];
my $line;
my $word;
my $clue;
my $wordLength;
my $mask;
my $lineCount;
my $t = time();
my %wordsOfLength;
my $wordCount;

my $directory = "./wordlists/$in{wordfile}/words/";
#read word and clue file
if (not -d $directory) {die "directory $directory does not exist"};

=pod
#build binary mask lists for all the word lengths 3-15
# @{ $binaryMasks{ $numberOfLetters ) }
for ( my $numberOfLetters = 2 ; $numberOfLetters < 21 ; $numberOfLetters++)
      {
      if ( $wordLength{$numberOfLetters} != 1 ) {next;}; #skip words that are of a length that are not on grid
      for ($decimal = 0 ; $decimal < 2 ** $numberOfLetters ; $decimal++)
            {
            my $mask = sprintf "%0*b" , $numberOfLetters , $decimal;   #convert to binary# ensure it is a string and has leading 0's
            push @{ $binaryMasks{$numberOfLetters} } , "$mask";
            }
      }
=cut

#new routine just loads word files of requested word lengths
#work files were separated earlier
foreach $wordLength ( keys %wordLengths)
         {
         $message = $message . "Loading words of length $wordLength...\n";
         &PrintProcessing($message);

         $filename = "$directory$wordLength\.txt";
         #$filename = "$directory/all.txt";
         open (DATA, "<$filename") or &Quit( "Word file $filename does not exist" );
         print '.'; #help keep alive on big loads

         foreach $word (<DATA>)
                  {
                  $word =~ s/\n//g; #remove line return
                  $word =~ s/\r//g; #remove line return
                  if ($word eq '') {next} #blank line. toss
                  $lineCount++;
                  $word = uc($word); #all words must be uppercase for standard, display and search reasons.
                  $wordsOfLength{$wordLength}++; #global var for statistics

                  #build $wordsOfLengthString[$wordLength] string
                  if ($wordsOfLengthString[$wordLength] eq '') {$wordsOfLengthString[$wordLength] = ','} #start string of words with a coma
                  $wordsOfLengthString[$wordLength] = "$wordsOfLengthString[$wordLength]$word,"; #build a comma delimited string of each possible word length

                  #letter by letter build here
                  my @lettersInWord =  split('' , $word);
                  my $letterPosition = 0;
                  #prep for new fast linear word search : $linearWordSearch{mask}
                  $mask = $word;
                  $mask =~ s/\S/o/g; #build a mask with ooooooooo of wordlength
                  foreach my $letter (@lettersInWord)
                           {
                           #build new fast linear word search : $linearWordSearch{mask}
                           $linearWordSearch{$mask}{ substr($word,$letterPosition,1) } = 1 ; #add letter for $letterPosition to set of hash keys for this $mask
                           substr ( $mask , $letterPosition , 1 , $letter); #change mask with next letter added to it Cooo to COoo
                           $letterPosition++;
                           }
=pod
                   foreach $mask (@{ $binaryMasks{$wordLength} })
                            {
                            #convert RICKETS into ooooooS oooooTo oooooTS , etc
                            #from : http://stackoverflow.com/questions/1871092/masking-a-string-in-perl-using-a-mask-string
                            #$str =~ s/(.)/substr($mask, pos $str, 1) eq 'o' ? $1 : 'x'/eg;
                            $maskedWord = $word;
                            $maskedWord =~ s/(.)/substr($mask, pos($maskedWord) , 1) eq '0' ? $1 : 'o'/eg; #mask the word with our boolean mask. replace all 0 positions in $mask with a o in our $maskedWord
                            #then we add RICKETS to ${ooooooS}{RICKETS} ${oooooTo}{RICKETS} ${oooooTS}{RICKETS} , etc
                            #$wordListByMask{$maskedWord}{$word} = '1'; # the keys built by $word are the list
                            push @{$wordListByMask{$maskedWord}} , $word;
                            #@kkeys = keys %{$wordListByMask{$maskedWord}};
                            }
=cut
                  }
         close (DATA);
         }

#done loading words. Let's calculate some statistics
foreach my $length (sort keys %wordsOfLength)
     {
     if ($debug ) {print "$length : $wordsOfLength{$length}\n";}
     $wordCount = $wordCount + $wordsOfLength{$length};
     }

my $tt = time() - $t;
if ($debug ) {print "$lineCount lines and $wordCount words loaded in $tt sec \n\n";}
}


*/

var gridsvar = 'These are some standard pre-generated grids. See below if you want to contribute other grids.';
var britishgridsvar = 'This will generate a random British style grid (double spaced). Nothe that it is not symetrical.';
var worddatabasevar = 'The more words we have in our database the easier it is to generate a crossword.';
var walkpathvar = 'The walk path is the order we try to lay down words. The path chosen can vastly improve the generation time. Different paths work better for different grids but Crossing Words is the best for most situations. Letter walks are the slowest and are provided only to test and prove this fact.';
var optimumbacktrackvar = 'Optimal Backtrack vastly speeds up the search by removing more than one word when we can no longer lay down another word. It will continue to remove words until it reaches a word that potentially caused the failure.';
var slowdownvar = 'Only use this if you want to see the walk in slow time. It is not useful in generating crosswords.';
var shufflevar = 'If unchecked, it will try to lay words down in alphabetic order. So it will generate the same puzzle each time. It is not useful in generating crosswords. It is only usefull if you want to replicate a crossword generation scenario.';
var simplewordmaskvar = 'This lets the recursion figure out if the crossing words will play nice. Although is speeds up the words layed per second, it is slower overall.';

//get processing.txt often
function Get_Processing()
        {
        // Assign handlers immediately after making the request,
        //and remember the jqxhr object for this request
        var d = new Date();
        var tm = d.getTime();
        var jqxhr = $.get( "./processing.txt?" + tm
                               , function(){ $("#PrintProcessing").html( jqxhr.responseText ); }
                                           , "html"
                                          )
                                          //.done(function() {} )
                                //.always(function() { //alert( "finished"); })
                                 .fail(function() { $("#PrintProcessing").html( '...no other crosswords running...' ); } );
        //setTimeout( "Get_Processing();" , 1000 ); //keep the ball rolling
        }

//get results.txt often
function Get_Results()
        {
        // Assign handlers immediately after making the request,
        //and remember the jqxhr object for this request
        var d = new Date();
        var tm = d.getTime();
        var jqxhr = $.get( "./results.txt?" + tm
                               , function(){ $("#PrintResults").html( jqxhr.responseText ); }
                                           , "html"
                                          )
                                          //.done(function() {} )
                                //.always(function() { //alert( "finished"); })
                                .fail(function() { $("#PrintResults").html( 'no results file' ); } );
        //setTimeout( "Get_Results();" , 1000 ); //keep the ball rolling
        }

// Attach a submit handler to the MyForm
$( "#StartForm" ).submit(
                                                function(event)
                                                        {
                                                        // Stop form from submitting normally
                                                        event.preventDefault();
                                                        // Get some values from elements on the page:
                                                        var $form = $( this ) , term = $form.serialize(), url = $form.attr( "action" );
                                                        // Send the data using post
                                                        var posting = $.post( url, term );
                                                        posting.done(
                                                                                function( data )
                                                                                        {
                                                                                        //$("#PrintResult").html( data );
                                                                                        alert(data);
                                                                                        }
                                                                                );
                                                        posting.fail(
                                                                                function( data )
                                                                                        {
                                                                                        //$("#PrintResult").html( data );
                                                                                        alert(data);
                                                                                        }
                                                                                );
                                                        //$("#PrintResult").html( 'Wait for it.....' ); #starts output directed to #PrintResult
                                                        }
                                                );

function pause(milliseconds) {
        var dt = new Date();
        while ((new Date()) - dt <= milliseconds) { /* Do nothing */ }
        }

// Attach a        submit handler to the EraseForm
$( "#EraseForm" ).submit( function( event )
                                               {
                                               // Stop form from submitting normally
                                               event.preventDefault();
                                               // Get some        values from elements on the page:
                                               var $form = $( this ), term = $form.serialize(), url = $form.attr( "action" );
                                               // Send the data using post
                                               var posting = $.post( url, term );
                                               posting.success( function(data){alert(data);} );
                                               posting.fail( function( data ){ alert(data); } );
                                               //alert('Stalled crossword erased');
                                               posting.done( function( data ){ asd = data; } );
                                               }
                                       );
//var timer1 = setInterval("Get_Processing();",1000); //start ball rolling
//var timer2 = setInterval( "Get_Results();" , 1000 ); //start the ball rolling
</SCRIPT> </BODY>
</HTML>
